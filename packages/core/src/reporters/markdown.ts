/**
 * Markdown Reporter
 * Generates Markdown output for PR comments and documentation
 */

import type {
  ValidationResult,
  ValidationStatus,
  ComparisonResult,
  BundleCorrelation,
  FixSuggestion,
  Regression,
} from '../contracts/types';
import { VERSION } from '../index';
import { countByStatus, getOverallStatus } from '../contracts/validator';

/**
 * Options for Markdown report generation
 */
export interface MarkdownReportOptions {
  /** Include fix suggestions */
  includeSuggestions?: boolean;
  /** Include historical trend (if data available) */
  includeHistoricalTrend?: boolean;
  /** Include passing components (collapsed) */
  includePassingComponents?: boolean;
  /** Maximum suggestions to show per component */
  maxSuggestionsPerComponent?: number;
  /** Collapse sections with details tags */
  collapseSections?: boolean;
}

const DEFAULT_OPTIONS: MarkdownReportOptions = {
  includeSuggestions: true,
  includeHistoricalTrend: false,
  includePassingComponents: true,
  maxSuggestionsPerComponent: 3,
  collapseSections: true,
};

/**
 * Status emoji mapping
 */
const STATUS_EMOJI: Record<ValidationStatus, string> = {
  pass: ':white_check_mark:',
  warn: ':warning:',
  fail: ':x:',
};

/**
 * Severity emoji mapping
 */
const SEVERITY_EMOJI: Record<string, string> = {
  high: ':red_circle:',
  medium: ':orange_circle:',
  low: ':yellow_circle:',
};

/**
 * Generate Markdown report from validation results
 */
export function generateMarkdownReport(
  results: ValidationResult[],
  options: MarkdownReportOptions = {}
): string {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const lines: string[] = [];

  // Header
  lines.push('## Performance Contract Report');
  lines.push('');

  // Summary table
  lines.push(generateSummaryTable(results));
  lines.push('');
  lines.push('---');
  lines.push('');

  // Failed contracts
  const failedResults = results.filter((r) => r.status === 'fail');
  if (failedResults.length > 0) {
    lines.push('### Contract Violations');
    lines.push('');
    for (const result of failedResults) {
      lines.push(generateComponentSection(result, opts));
      lines.push('');
    }
    lines.push('---');
    lines.push('');
  }

  // Warning contracts
  const warningResults = results.filter((r) => r.status === 'warn');
  if (warningResults.length > 0) {
    lines.push('### Warnings');
    lines.push('');
    for (const result of warningResults) {
      lines.push(generateComponentSection(result, opts));
      lines.push('');
    }
    lines.push('---');
    lines.push('');
  }

  // Passing contracts
  if (opts.includePassingComponents) {
    const passingResults = results.filter((r) => r.status === 'pass');
    if (passingResults.length > 0) {
      lines.push('### Passing Contracts');
      lines.push('');
      if (opts.collapseSections) {
        lines.push('<details>');
        lines.push(
          `<summary>${passingResults.length} components passing</summary>`
        );
        lines.push('');
      }
      lines.push(generatePassingTable(passingResults));
      if (opts.collapseSections) {
        lines.push('');
        lines.push('</details>');
      }
      lines.push('');
    }
  }

  // Footer
  lines.push('---');
  lines.push('');
  lines.push(
    `<sub>Generated by [perflock](https://github.com/samithahansaka/perflock) v${VERSION}</sub>`
  );

  return lines.join('\n');
}

/**
 * Generate Markdown report with comparison data
 */
export function generateMarkdownReportWithComparison(
  results: ValidationResult[],
  comparison: ComparisonResult,
  bundleAnalysis?: BundleCorrelation,
  options: MarkdownReportOptions = {}
): string {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const lines: string[] = [];

  // Header
  lines.push('## Performance Contract Report');
  lines.push('');

  // Summary table with regression count
  lines.push(generateSummaryTableWithRegressions(results, comparison));
  lines.push('');
  lines.push('---');
  lines.push('');

  // Contract violations (same as before)
  const failedResults = results.filter((r) => r.status === 'fail');
  if (failedResults.length > 0) {
    lines.push('### Contract Violations');
    lines.push('');
    for (const result of failedResults) {
      lines.push(generateComponentSection(result, opts, bundleAnalysis));
      lines.push('');
    }
    lines.push('---');
    lines.push('');
  }

  // Regressions section
  if (comparison.regressions.length > 0) {
    lines.push('### Regressions Detected');
    lines.push('');
    for (const regression of comparison.regressions) {
      lines.push(generateRegressionSection(regression, bundleAnalysis, opts));
      lines.push('');
    }
    lines.push('---');
    lines.push('');
  }

  // Improvements section
  if (comparison.improvements.length > 0) {
    lines.push('### Improvements');
    lines.push('');
    if (opts.collapseSections) {
      lines.push('<details>');
      lines.push(
        `<summary>${comparison.improvements.length} improvements</summary>`
      );
      lines.push('');
    }
    lines.push(generateImprovementsTable(comparison.improvements));
    if (opts.collapseSections) {
      lines.push('');
      lines.push('</details>');
    }
    lines.push('');
    lines.push('---');
    lines.push('');
  }

  // Passing contracts
  if (opts.includePassingComponents) {
    const passingResults = results.filter((r) => r.status === 'pass');
    if (passingResults.length > 0) {
      lines.push('### Passing Contracts');
      lines.push('');
      if (opts.collapseSections) {
        lines.push('<details>');
        lines.push(
          `<summary>${passingResults.length} components passing</summary>`
        );
        lines.push('');
      }
      lines.push(generatePassingTable(passingResults));
      if (opts.collapseSections) {
        lines.push('');
        lines.push('</details>');
      }
      lines.push('');
    }
  }

  // Footer
  lines.push('---');
  lines.push('');
  lines.push(
    `<sub>Generated by [perflock](https://github.com/samithahansaka/perflock) v${VERSION}</sub>`
  );

  return lines.join('\n');
}

/**
 * Generate summary table
 */
function generateSummaryTable(results: ValidationResult[]): string {
  const counts = countByStatus(results);
  const status = getOverallStatus(results);

  return `### Summary
| Metric | Value |
|--------|-------|
| Status | ${STATUS_EMOJI[status]} ${status.charAt(0).toUpperCase() + status.slice(1)} |
| Components Tested | ${results.length} |
| Contracts Passed | ${counts.pass} |
| Contracts Warning | ${counts.warn} |
| Contracts Failed | ${counts.fail} |`;
}

/**
 * Generate summary table with regression count
 */
function generateSummaryTableWithRegressions(
  results: ValidationResult[],
  comparison: ComparisonResult
): string {
  const counts = countByStatus(results);
  const status = getOverallStatus(results);

  return `### Summary
| Metric | Value |
|--------|-------|
| Status | ${STATUS_EMOJI[status]} ${status.charAt(0).toUpperCase() + status.slice(1)} |
| Components Tested | ${results.length} |
| Contracts Passed | ${counts.pass} |
| Contracts Warning | ${counts.warn} |
| Contracts Failed | ${counts.fail} |
| Regressions | ${comparison.regressions.length} |
| Improvements | ${comparison.improvements.length} |`;
}

/**
 * Generate component section
 */
function generateComponentSection(
  result: ValidationResult,
  options: MarkdownReportOptions,
  _bundleAnalysis?: BundleCorrelation
): string {
  const lines: string[] = [];
  const emoji = STATUS_EMOJI[result.status];

  if (options.collapseSections) {
    lines.push('<details>');
    lines.push(
      `<summary><strong>${emoji} ${result.componentName}</strong> - ${getStatusDescription(result)}</summary>`
    );
    lines.push('');
  } else {
    lines.push(`#### ${emoji} ${result.componentName}`);
    lines.push('');
  }

  // Metrics table
  lines.push('| Metric | Budget | Actual | Status |');
  lines.push('|--------|--------|--------|--------|');

  if (result.metrics.renderTime) {
    const rt = result.metrics.renderTime;
    lines.push(
      `| Render Time | ${rt.budget}ms | ${rt.actual.toFixed(2)}ms | ${STATUS_EMOJI[rt.status]} ${getUtilizationText(rt.utilization)} |`
    );
  }

  if (result.metrics.renderCount) {
    const rc = result.metrics.renderCount;
    lines.push(
      `| Render Count | ${rc.budget} | ${rc.actual} | ${STATUS_EMOJI[rc.status]} ${getUtilizationText(rc.utilization)} |`
    );
  }

  if (result.metrics.rendersPerInteraction) {
    for (const [type, validation] of Object.entries(
      result.metrics.rendersPerInteraction
    )) {
      if (validation) {
        lines.push(
          `| Renders/${type} | ${validation.budget} | ${validation.actual} | ${STATUS_EMOJI[validation.status]} ${getUtilizationText(validation.utilization)} |`
        );
      }
    }
  }

  // Suggestions
  if (options.includeSuggestions && result.suggestions.length > 0) {
    lines.push('');
    lines.push('**Suggested Fixes:**');
    lines.push('');

    const suggestions = result.suggestions.slice(
      0,
      options.maxSuggestionsPerComponent
    );

    for (let i = 0; i < suggestions.length; i++) {
      lines.push(generateSuggestionBlock(suggestions[i], i + 1));
      lines.push('');
    }

    if (result.suggestions.length > suggestions.length) {
      lines.push(
        `*...and ${result.suggestions.length - suggestions.length} more suggestions*`
      );
    }
  }

  if (options.collapseSections) {
    lines.push('</details>');
  }

  return lines.join('\n');
}

/**
 * Generate suggestion block
 */
function generateSuggestionBlock(
  suggestion: FixSuggestion,
  index: number
): string {
  const severityEmoji = SEVERITY_EMOJI[suggestion.severity] || '';
  const lines: string[] = [];

  lines.push(
    `${index}. **[${suggestion.severity.toUpperCase()}]** ${severityEmoji} Line ${suggestion.line}: ${suggestion.pattern}`
  );

  if (suggestion.codeSnippet) {
    lines.push('   ```tsx');
    lines.push(`   // Current`);
    lines.push(`   ${suggestion.codeSnippet}`);
    lines.push('');
    lines.push(`   // Suggested fix: ${suggestion.fix}`);
    lines.push('   ```');
  } else {
    lines.push(`   > ${suggestion.description}`);
    lines.push(`   > **Fix:** ${suggestion.fix}`);
  }

  return lines.join('\n');
}

/**
 * Generate regression section
 */
function generateRegressionSection(
  regression: Regression,
  bundleAnalysis: BundleCorrelation | undefined,
  options: MarkdownReportOptions
): string {
  const lines: string[] = [];
  const emoji = regression.significant ? ':warning:' : ':information_source:';

  if (options.collapseSections) {
    lines.push('<details>');
    lines.push(
      `<summary><strong>${emoji} ${regression.componentName}</strong> - ${Math.abs(regression.changePercent * 100).toFixed(0)}% ${regression.changePercent > 0 ? 'slower' : 'faster'}</summary>`
    );
    lines.push('');
  } else {
    lines.push(
      `#### ${emoji} ${regression.componentName} - ${regression.metric}`
    );
    lines.push('');
  }

  lines.push('| Metric | Baseline | Current | Change |');
  lines.push('|--------|----------|---------|--------|');
  lines.push(
    `| ${regression.metric} | ${formatValue(regression.baseline)} | ${formatValue(regression.current)} | ${formatChange(regression.changePercent)} |`
  );

  // Bundle correlation
  if (bundleAnalysis?.hasCorrelation) {
    lines.push('');
    lines.push('**Bundle Correlation:**');
    lines.push('> This regression may correlate with bundle size changes:');
    for (const chunk of bundleAnalysis.chunkChanges) {
      if (chunk.sizeChange > 0) {
        lines.push(
          `> - \`${chunk.name}\` increased by ${formatBytes(chunk.sizeChange)}`
        );
        if (chunk.addedModules.length > 0) {
          lines.push(`>   Added: ${chunk.addedModules.join(', ')}`);
        }
      }
    }
    for (const alt of bundleAnalysis.suggestedAlternatives) {
      lines.push(
        `> - Consider replacing \`${alt.dependency}\` (${formatBytes(alt.currentSize)}) with \`${alt.alternative}\` (${formatBytes(alt.alternativeSize)})`
      );
    }
  }

  if (options.collapseSections) {
    lines.push('');
    lines.push('</details>');
  }

  return lines.join('\n');
}

/**
 * Generate passing components table
 */
function generatePassingTable(results: ValidationResult[]): string {
  const lines: string[] = [];

  lines.push('| Component | Render Time | Budget | Utilization |');
  lines.push('|-----------|-------------|--------|-------------|');

  for (const result of results) {
    const rt = result.metrics.renderTime;
    if (rt) {
      lines.push(
        `| ${result.componentName} | ${rt.actual.toFixed(2)}ms | ${rt.budget}ms | ${(rt.utilization * 100).toFixed(0)}% :white_check_mark: |`
      );
    } else {
      lines.push(`| ${result.componentName} | - | - | :white_check_mark: |`);
    }
  }

  return lines.join('\n');
}

/**
 * Generate improvements table
 */
function generateImprovementsTable(improvements: Regression[]): string {
  const lines: string[] = [];

  lines.push('| Component | Metric | Improvement |');
  lines.push('|-----------|--------|-------------|');

  for (const imp of improvements) {
    lines.push(
      `| ${imp.componentName} | ${imp.metric} | ${formatChange(imp.changePercent)} :arrow_down: |`
    );
  }

  return lines.join('\n');
}

/**
 * Helper functions
 */
function getStatusDescription(result: ValidationResult): string {
  if (result.status === 'fail') {
    return `${result.violations.length} budget(s) exceeded`;
  }
  if (result.status === 'warn') {
    return 'Approaching budget limits';
  }
  return 'All budgets within limits';
}

function getUtilizationText(utilization: number): string {
  const percent = (utilization * 100).toFixed(0);
  if (utilization > 1) {
    return `Exceeded by ${((utilization - 1) * 100).toFixed(0)}%`;
  }
  return `${percent}%`;
}

function formatValue(value: number): string {
  if (value < 1) {
    return value.toFixed(2);
  }
  if (value < 10) {
    return value.toFixed(1);
  }
  return Math.round(value).toString();
}

function formatChange(changePercent: number): string {
  const sign = changePercent > 0 ? '+' : '';
  return `${sign}${(changePercent * 100).toFixed(0)}%`;
}

function formatBytes(bytes: number): string {
  if (bytes < 1024) {
    return `${bytes}B`;
  }
  if (bytes < 1024 * 1024) {
    return `${(bytes / 1024).toFixed(1)}KB`;
  }
  return `${(bytes / (1024 * 1024)).toFixed(1)}MB`;
}
